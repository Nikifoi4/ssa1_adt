# Bash

> пилится

## Проблема автоматизаци

В жизни сисадмина много рутины. Одни и те же действия, которые приходится проделывать сотни раз.

Взять те же бэкапы. Их делать нужно, но это крайне мутарно.

1. Создать временный архив
2. Найти все нужные каталоги и файлы
3. Скопировать их в наш временный архив
4. Зжать его
5. Переместить на сервер бэкапов

И ещё множество таких же рутинных задач.

Что бы не помереть со скуки и не допускать ошибок люди придумали скрипты.

## Что такое скрипт

Когда мы вводим команды в терминал, мы даём последовательно инструкции на выполнение нашей командной оболочке. Но вместо этого мы можем собрать все команды в правильном порядке и с нужными параметрами в один файл, и когда нам нужно что-либо сделать запускать его.

Такой файл с инструкциями и называется скриптом.

Мы будем говорить конкретно про скрипты на bash

## #!

При попытке запуска не бинарного файла, Linux смотрит на его первую строчку.

```
#! /bin/bash
```

Если в ней указано специальное сочетание символов `#!`, то все последующие строки будут запущены при помощи программы указанной после(в данном примере при помощи `/bin/bash`)

Скрипты на баш выглядят крайне просто

```
#! /bin/bash

echo Э мамбо, мамбо италиано
echo Го го го миксед ап силиано
```

И помогают нам автоматизировать всю свою рутину

## Переменные

В баш есть переменные. Для присваивания переменной мы пишем её имя, затем в плотную к имени знак равенства `=`, после чего значение переменной. А для получения значений используется знак доллара `$` и имя переменной.

```
#! /bin/bash

line1="Э мамбо, мамбо италиано"
line2="Го го го миксед ап силиано"
echo $line1
echo $line2
```

## Внешние значения

Мы можем принимать различные параметры от пользователя. И один из распрастранённых способов - получение данных из флагов

Обращаясь к переменным `$1-9` и `${10-999999999999999999999999999999999999999}` мы можем получить заданные пользователем параметры Например эта программа

```
#! /bin/bash

echo $1
```

будет выводить нам всё что мы передадим ей как первый аргумент.

## if

Следует сразу сказать о том, что bash имеет местами крайне специфический синтаксис и дабы его полноценно принять вам понадобится хорошенько по вкуривать маны и пописать на нём.

If - условный оператор. Делает действие в зависимости от того успешно ли выполнилась команда.

```
#! /bin/bash

if [[ $1 == "yes" ]]; then
	echo no
elif [[ $1 == "no" ]]; then
	echo yes
else
	echo непанимаю
fi
```

Вместо `[[...]]` может быть любая команда, даже `ls`. И при успешно её выполнение действие будет выполненно.

### \[, \[\[ и ((

В баше с условиями всё не так просто, как могло бы показаться на первый взгляд.

Хоть мы и видим скобочки, но работают они совсем иначе.

Возьмём пример

```
if [ "1" -eq "1"]
then
    echo 1
fi
```

Как вы видите у нас исчезли и двойные скобочки, и точка с запятой, но почем?

`[`, `[[` и `((` - это команды, а всё что после, вплоть до then или точки с запятой - их аргументы.

Но куда делась точка с запятой?

Всё просто. В повседневной работе с линуксом, когда вы хотите выполнить несколько команд вы используете символы для разделения `;` и `&&`

`;` выполнит следующую за ним команду в любом случае, а `&&`, только если предыдущая была выполнена успешно.

Отсюда и такой замысловатый синтаксис.

&#x20;`[` и  `[[` - практически идентичны, разница лишь в том, что `[[` не совсем команда, а скорее спец слово, за счёт чего мы можем использовать логические операторы `||` (или) и `&&` (и).

Но и в `[` и в  `[[`, в основном используются вот такие слова для обозначения логических операций:

```
-z # строка пуста
-n # строка не пуста
=, (==) # строки равны
!= # строки неравны
-eq # равно
-ne # неравно
-lt,(< ) # меньше
-le,(<=) # меньше или равно
-gt,(>) #больше
-ge,(>=) #больше или равно
! #отрицание логического выражения
-a,(&&) #логическое «И»
-o,(||) # логическое «ИЛИ»
```

Например

```
#!/bin/bash
source=$1 
dest=$2

if [[ "$source" -eq "$dest" ]]
then 
exit 1 # выходим с ошибкой (1 - код ошибки)
else 
cp $source $dest
echo "Удачное копирование!"
fi
```

&#x20;

## Func

## Задание

Написать скрипт выполняющий[ это задание](../linux/terminal-basics.md#zadanie)
